//
//  SourceryExamplesTests.swift
//  SourceryExamplesTests
//
//  Created by stnamco on 2018/10/16.
//  Copyright © 2018年 namco. All rights reserved.
//

@testable import SourceryExamples
import SwiftCheck
import XCTest

class SourceryExamplesTests: XCTestCase {
    override func setUp() {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testExample() {
        // This is an example of a functional test case.
        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }
    
    func testPerformanceExample() {
        // This is an example of a performance test case.
        measure {
            // Put the code you want to measure the time of here.
        }
    }
    
    func testDump() {
        // 'property' notation allows us to name our tests.  This becomes important
        // when they fail and SwiftCheck reports it in the console.
        property("Integer Equality is Reflexive") <- forAll { (item: Repository) in
            print("generated item: \(item)")
            return item == item
        }
    }
    
    func testReversedArray() {
        property("The reverse of the reverse of an array is that array") <- forAll { (items: [Repository]) in
            // This property is using a number of SwiftCheck's more interesting
            // features.  `^&&^` is the conjunction operator for properties that turns
            // both properties into a larger property that only holds when both sub-properties
            // hold.  `<?>` is the labelling operator allowing us to name each sub-part
            // in output generated by SwiftCheck.  For example, this property reports:
            //
            // *** Passed 100 tests
            // (100% , Right identity, Left identity)
            //            var arr = xs
            (items.reversed().reversed() == items) <?> "Left identity"
                ^&&^
                (items == items.reversed().reversed()) <?> "Right identity"
        }
    }
}
